# Hello, world!

## Persiapan
Halo, Selamat datang. Sebelum mulai, mari kita persiapkan alat-alat yang akan digunakan.

### Alat-alat yang dibutuhkan:
* **NASM** (Netwide Assembler)
* **ld** (GNU linker) atau **lld** (LLVM ELF linker)
* **x86-64** (GNU/)**Linux**
* **GDB** (GNU Debugger)

## Membuat program dasar
Buatlah sebuah file dengan nama `hello.asm` menggunakan text editor kesukaan kalian.

Di sini saya menggunakan text editor `nano`. jadi saya menjalankan 

` $ nano hello.asm`

Tulislah kode dibawah ini

```asm
%define STDOUT_FILENO 1

section .rodata
        msg db "Hello, world!", 10, 0

section .text
        global _start
        
_start:
        mov eax, 1
        mov edi, STDOUT_FILENO
        mov esi, msg
        mov edx, 14
        syscall
        
        mov eax, 60
        syscall
```

![image](https://user-images.githubusercontent.com/86765295/167515691-f7de1722-6e40-43ab-8a10-fb79182d12b6.png)


Setelah selesai, tekan `Ctrl+X`, `y`, dan `enter` .

Jalankan 

`$ nasm hello.asm -f elf64`.

Hasi keluaran dari `nasm` belum bisa dijalankan karena hanya berupa `.o` (baca: **object**) file saja.

Oleh karena itu jalankan 

`$ ld main.o -o main`

, agar linker bisa me-link object file tersebut dan menghasilkan executable.

Kita sudah berhasil membuat executablenya, sekarang mari kita eksekusi.

`$ ./hello`

Tada, program yang kita buat menghasilkan output _"Hello, world!"_

# Dasar-dasar

## Bagian-bagian program.
Dalam sebuah program, terdapat beberapa bagian/seksi.

Setidaknya ada 4 bagian yang umum

- **.data**
- **.rodata**
- **.bss**
- **.text**

> *Perlu dingat, isi semua bagian di atas (kecuali .text) adalah `static`

### section .data

Lokasi data-data yang sudah di-inisialisasi berada di sini. 

`section .data` ini bersifat **rw**- (*read write*).

### section .rodata

Tempat data konstan atau tidak bisa diubah.

Dalam bahasa C/C++, tempat global `const` atau `const static` berada.

Seperti namanya, `.rodata` ini **r**-- (*read only*).

### section .bss

Memori yang dialokasi untuk dipakai nanti disimpan di sini.

> Note: unitialized static data secara default akan bernilai 0

`.bss` bersifat **rw**- (*read write*).

### section .text

Tempat kode-kode yang akan dijalankan program.

Sifatnya **r**-**x** (*read exec*).

----

> Apakah moderasi tiap bagian bisa diubah ?

Ya bisa, tapi untuk sekarang kita tidak akan membahas itu.

## System Call

> _Apa itu system call ?_

System call adalah cara program berinteraksi dengan sistem operasi melalui kernel.

Saat kita melakukan syscall, kita menyuruh kernel untuk melakukan fungsi.

_Gak Paham ?_

Bahasa awamnya, **system call adalah fungsi-fungsi yang tersedia di kernel.**

# Penjelasan 

`%define` di sini adalah macro.

jadi 

```asm
%define STDOUT_FILENO 1
```

sama seperti

```c
#define STDOUT_FILENO 1
```
dalam bahasa C/C++, dan macro ini bebas kita letakkan di mana saja.

##  `section .rodata`

`db` merupakan singkatan dari "_**d**efine **b**yte(s)_"

Seperti yang kita tahu, ukuran `char` di Linux x64 adalah 1 byte / 8 bit.

**10** adalah Nilai ASCII untuk `'\n'` atau escape character _newline_

dan **0** adalah Nilai ASCII untuk `'\0'` atau NULL character.

Jadi 

```asm
msg db "Hello, world!", 10, 0
```

sama seperti

```c
const static char msg[] = "Hello, world!\n"
```

> Note : Dikarenakan `msg` berada dalam `.rodata`, maka **msg** bersifat `static` dan `const` .

## .section .text

Sebelum kita lanjut ke pembahasan selanjutnya, saya ingin membuat analogi system call kernel dengan restoran.


`mov(e)`  adalah operasi assign atau sama seperti operator sama dengan "*=*" di dalam bahasa C/C++.

`mov eax, 1` berarti memasukkan nilai **1** ke dalam register eax. atau

```c
eax = 1;
```

Nomor system call di Linux ditentukan oleh register `rax`.

N







