# Hello, world!

## Persiapan
Halo, Selamat datang. Sebelum mulai, mari kita persiapkan alat-alat yang akan digunakan.

### Alat-alat yang dibutuhkan:
* **NASM** (Netwide Assembler)
* **ld** (GNU linker) atau **lld** (LLVM ELF linker)
* **x86-64** (GNU/)**Linux**
* **GDB** (GNU Debugger)

## Membuat program dasar
Buatlah sebuah file dengan nama `hello.asm` menggunakan text editor kesukaan kalian.

Di sini saya menggunakan text editor `nano`. jadi saya menjalankan 

` $ nano hello.asm`

Tulislah kode dibawah ini

```asm
[section .rodata]
        msg db `Hello, world!\n\0`

[section .text]
        global _start
        
_start:
        mov eax, 1
        mov edi, 1
        mov esi, msg
        mov edx, 14
        syscall
        
        mov eax, 60
        syscall
```

![gambar](https://user-images.githubusercontent.com/86765295/172286340-6d7ba111-8fdf-4cfe-9b6d-47f2a65625f0.png)

Setelah selesai, tekan `Ctrl+X`, `Y`, dan `enter` .

Jalankan 

`$ nasm -f elf64 hello.asm`.

Hasi keluaran dari `nasm` belum bisa dijalankan karena hanya berupa `.o` (baca: **object**) file saja.

Oleh karena itu jalankan 

`$ ld main.o -o main`

, agar linker bisa me-link object file tersebut dan menghasilkan executable.

Kita sudah berhasil membuat executablenya, sekarang mari kita eksekusi.

`$ ./hello`

Tada, program yang kita buat menghasilkan output _"Hello, world!"_

# Dasar-dasar

## Bagian-bagian program.
Dalam sebuah program, terdapat beberapa bagian/seksi.

Setidaknya ada 4 bagian yang umum

- **.data**
- **.rodata**
- **.bss**
- **.text**

Untuk membuat bagian, kita menggunakan keyword `section .nama`

di mana `.nama` adalah nama bagian yang kita ingin buat.

> *Perlu dingat, isi semua bagian di atas (kecuali .text) adalah `static`*

### [section .data]

Lokasi data-data yang sudah di-inisialisasi berada di sini. 

`section .data` ini bersifat **rw**- (*read write*).

### [section .rodata]

Tempat data konstan atau tidak bisa diubah.

Dalam bahasa C/C++, tempat global `const` atau `const static` berada.

Seperti namanya, **.rodata** ini **r**-- (*read only*).

### [section .bss]

Memori statis yang dialokasi untuk dipakai nanti disimpan di sini.

> Note: unitialized static data secara default akan bernilai 0

**.bss** bersifat **rw**- (*read write*).

### [section .text]

Tempat kode-kode yang akan dijalankan program.

Sifatnya **r**-**x** (*read exec*).

<br/>

> Apakah moderasi tiap bagian bisa diubah ?

Ya bisa, tapi untuk sekarang kita tidak akan membahas itu.

## System Call

> _Apa itu system call ?_

System call adalah cara program berinteraksi dengan sistem operasi melalui kernel.

Saat kita melakukan syscall, kita menyuruh kernel untuk melakukan fungsi.

_Gak Paham ?_

Bahasa awamnya, **system call adalah fungsi-fungsi yang tersedia di kernel.**

## Instruksi dasar
NASM menggunakan syntax intel.

Bentuk syntaxnya kurang lebih sebagai berikut

```
instruksi dest, src
```
<br/>

`mov` (_move_) adalah instruksi untuk memindahkan data ke dalam memori atau register.

`mov x, y` sama seperti `x = y`.

<br/>

`xor` adalah operasi bitwise _xor_ .

`xor x, y` sama seperti `x ^= y`.

<br/>

`syscall` adalah instruksi untuk memanggil system call dari kernel

## Calling convention
Perhatikan penggunaan register untuk system call Linux x64 ini.

- **rax** digunakan untuk menentukan nomor syscall
- **rdi** digunakan untuk memberikan argumen pertama
- **rsi** digunakan untuk memberikan argumen kedua
- **rdx** digunakan untuk memberikan argumen ketiga
- **r10** digunakan untuk memberikan argumen keempat
- **r8** digunakan untuk memberikan argumen kelima
- **r9** digunakan untuk memberikan argumen keenam


| SYSCALL_NR | arg0 | arg 1 | arg2 | arg3 | arg4 | arg5 |
|------------|------|--------|--------|-----|----|----|
| RAX | RDI | RSI | RDX | R10 | R8 | R9 | R10 |

Kalian juga bisa baca-baca `man 2 syscall`.

Penjelasan lebih lanjut tentang calling-convention ini akan kita lanjut di bab calling convention.

<br/>

> Fun fact: Calling convention di atas adalah kernelspace System V ABI untuk arsitektur amd64
> 
> Yang di mana juga digunakan untuk semua os \*nix seperti BSD, Darwin, yang berarsitektur amd64

# Penjelasan 

##  [section .rodata]

`db` merupakan singkatan dari "_**d**efine **b**yte(s)_"

Seperti yang kita tahu, ukuran `char` di Linux x64 adalah 1 byte / 8 bit.

`'\n'` escape character untuk _newline_

`'\0'` untuk karakter **NULL**.

Jadi 

```asm
msg db `Hello, world!\n\0`
```

sama seperti

```c
static const char msg[] = "Hello, world!\n"
```

> Note : Dikarenakan **msg** berada dalam **.rodata**, maka **msg** bersifat `static` dan `const` .

## [section .text]

Sebelum kita lanjut ke pembahasan selanjutnya, saya ingin membuat analogi system call kernel dengan menu restoran.

**nomenu** digunakan untuk menentukan menu makanan (seperti **rax** yang menentukan nomor syscall).

**ket1** digunakan untuk keterangan pertama / argumen pertama (seperti **rdi**).

Berikut adalah contoh tabel menu makanan

| Nama makanan | nomenu | ket1 |
| ------------ | ------- | ---- |
| Lemper Jepang     |    1    | jumlah | 
| Tahu Bulat | 2 | jumlah |

<br/>

Instruksi `isi` digunakan untuk mengisi.

Instruksi `pesan` digunakan untuk memanggil pelayan atau menandakan kita siap memesan

<br/>

Kita diberikan kertas pesanan sebagai berikut

| No menu | ket1 |
| ------- | ----- |
|  ...  |   ...  |

Jika kita ingin memesan Lemper jepang maka kita mengisi tabelnya sebagai berikut

| No menu | ket1 |
| ------- | ---- |
|    1     |  1 |

Jika dituliskan dalam bentuk pseudocode assembly kurang lebih seperti di bawah ini.

```
isi nomenu, 1
; Mengisi nomenu dengan angka 1
isi ket1, 5
; Mengisi ket1 dengan angka 5
pesan
; Memesan lemper jepang sebanyak 5 buah
```
Maka pelayan akan menerima pesanan "Lemper Jepang", berdasarkan **nomenu** dan menyajikan 5 buah lemper berdasarkan **ket1**.

Dalam fungsi C/C++, kode di atas sama seperti

`lemper_jepang(5);`

----------------------------------------------------------------------------

Oke, kita kembali ke materi.

`global _start` digunakan agar linker bisa mengakses label **_start** dari luar.

label **_start** sama seperti fungsi **main** dalam bahasa C/C++.

Kita akan melakukan syscall **write** untuk mengeluarkan output _"Hello, world!"_ ke command line.

Prototipe **sys_write** adalah sebagai berikut

```c
write(int fd, const void *buf, size_t count);
```
|  syscall  | rax | rdi | rsi |  rdx  | r10 | r8 | r9 |
| --------- | --- | --- | --- | ---- | ---- | --- | -- |
| write |  1  | fd  | buf | count |  -  |  - |  - |

> Referensi : man 2 write

<br/>

```c
mov eax, 1
``` 
Memasukkan nilai 1 ke dalam **eax**.

Sekarang, register **rax** sudah terisi dengan nilai 1

<br/>

###
```asm
mov edi, 1
```
Memasukkan nomor fd 1 ke dalam **edi**.

Argumen pertama untuk **sys_write** adalah nomor file descriptor untuk ditulis

Karena kita ingin menampilkan pesan ke **stdout** maka kita mengisi **rdi** dengan nilai 1.

<br/>

Saat suatu program dijalankan, setidaknya ada 3 stream yang secara default sudah terbuka.
 
**stdin** untuk menerima input, 

**stdout** menampilkan output,

dan **stderr** untuk menampilkan pesan diagnosa atau error.
 
Ketiga stream tadi memilki nomor file descriptor yang tetap.

Berikut adalah tabel 3 standard streams dan nomornya.

   | fd | value |
   | ---| ------ |
   | stdin | 0 |
   | stdout | 1 |
   | stderr | 2|
   
 `<unistd.h>` memilki tiga macro yang mendefinisikan nomor ketiga standard stream.
 
 ```c
 #define STDIN_FILENO 0
 #define STDOUT_FILENO 1
 #define STDERR_FILENO 2
 ```
 - https://en.wikipedia.org/wiki/File_descriptor

<br/>

###
```asm
mov esi, msg
``` 
Mengisi **esi** dengan alamat **msg**.

Argumen kedua syscall **write** adalah alamat data yang ingin ditulis.

Jadi sekarang register **rsi** berisi nilai alamat dari string **msg**

<br/>

###
```asm
mov edx, 14
```

Mengisi **edx** dengan nilai 14.

Argumen ketiga **sys_write** adalah jumlah bytes yang ingin ditulis

Ukuran **msg** tanpa karakter **NULL** adalah 14 bytes.

<br/>

Kode-kode di atas tadi jika diubah ke dalam bahasa C sama seperti

```c
write(1, msg, 14)
```

**sys_write** sudah selesai sekarang kita bisa memanggil kernel dengan instruksi `syscall`

<br/>
<br/>

> Pertanyaan, Mengapa mengisi ke **eax**; **edi**, **esi**, **edx** 
> padahal register yang dipakai **rax**, **rdi**, **rsi**, **rdx** ?

**eax** dan kawan-kawannya berukuran 32 bit, sedangkan **rax** dan kawan-kawannya berukuran 64 bit. 

Mengubah nilai register 32 bit juga akan mengubah nilai register 64 bit.

Kita akan bahas alasannya di bab berikutnya.

<br/>
<br/>

Selanjutnya kita akan melakukan syscall exit untuk menghentikan program

Prototipenya

```c
_exit(int status)
```

| syscall  | rax |   rdi  | rsi | rdx | r10 | r8 | r9 |
| ---------|-----|--------|-----|-----|-----|----|----|
| sys_exit |  60 | status |  -  |  -  |  -  |  - |  - |

> Referensi : man 2 exit
<br/>

```asm
mov eax, 60
```

Mengisi **eax** dengan nilai 60.

Nomor syscall untuk **sys_exit** adalah 60.

<br/>

###
```asm
xor edi, edi
```

Membuat register **edi**  bernilai 0 dengan instruksi bitwise `xor`.

`xor edi, edi` digunakan untuk mengisi **edi** dengan nilai 0 karena lebih ringan dibanding `mov edi, 0`.

<br/>

Hasilnya

```c
_exit(0)
```

syscall **\_exit** sudah selesai jadi kita memanggil kernel dengan instruksi `syscall` untuk melakukan **sys\_exit**.

<br/>

Pelajaran pertama untuk x64 Linux Assembly sudah selesai >//<, selanjutnya kita akan membahas register dan memori.


## Extra

Kalian bisa mengecek syscall yang dilakukan suatu program menggunakan `strace`.

![gambar](https://user-images.githubusercontent.com/86765295/170260303-672ce31a-5961-4f71-a30f-12dadea00f97.png)

Nampak di atas kalau program yang tadi kita buat melakukan **sys\_write** dan **sys\_exit** .

<br/>

Kalian juga bisa memanggil **syscall-syscall** di atas menggunakan bahasa C.

```c
#include <unistd.h>

int main(void)
{
        static const char msg[] = "Hello, world!\n";
        write(STDOUT_FILENO, msg, 14);
        _exit(0);
}
```

Compile dengan perintah di bawah ini.

`$ cc main.c -O2 -S -masm=intel -fno-pie`

Compiler di atas tidak akan menghasilkan program / object, dia hanya memberikan output assembly dari program yang akan dicompile.

Outputnya akan menghasilkan `main.s`.

Berikut hasil assembly dari clang.

![gambar](https://user-images.githubusercontent.com/86765295/170271193-076765ca-a6eb-4b34-9b4b-0613b9a23b13.png)

Hampir sama bukan ;).

Untuk tabel syscall linux x64 bisa dilihat di sini 
- https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit

Untuk yang offline bisa dilihat di `man syscalls` dan nomornya 

bagi yang menggunakan glibc ada di sini `/usr/include/x86_64-linux-gnu/asm/unistd_64.h`

