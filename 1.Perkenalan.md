# Hello, world!

## Persiapan
Halo, Selamat datang. Sebelum mulai, mari kita persiapkan alat-alat yang akan digunakan.

### Alat-alat yang dibutuhkan:
* **NASM** (Netwide Assembler)
* **ld** (GNU linker) atau **lld** (LLVM ELF linker)
* **x86-64** (GNU/)**Linux**
* **GDB** (GNU Debugger)

## Membuat program dasar
Buatlah sebuah file dengan nama `hello.asm` menggunakan text editor kesukaan kalian.

Di sini saya menggunakan text editor `nano`. jadi saya menjalankan 

` $ nano hello.asm`

Tulislah kode dibawah ini

```asm
%define STDOUT_FILENO 1

[section .rodata]
        msg db "Hello, world!", 10, 0

[section .text]
        global _start
        
_start:
        mov eax, 1
        mov edi, STDOUT_FILENO
        mov esi, msg
        mov edx, 14
        syscall
        
        mov eax, 60
        syscall
```

![image](https://user-images.githubusercontent.com/86765295/169317966-9ecf9e97-de98-4128-89ee-95cbbd484cbd.png)


Setelah selesai, tekan `Ctrl+X`, `y`, dan `enter` .

Jalankan 

`$ nasm hello.asm -f elf64`.

Hasi keluaran dari `nasm` belum bisa dijalankan karena hanya berupa `.o` (baca: **object**) file saja.

Oleh karena itu jalankan 

`$ ld main.o -o main`

, agar linker bisa me-link object file tersebut dan menghasilkan executable.

Kita sudah berhasil membuat executablenya, sekarang mari kita eksekusi.

`$ ./hello`

Tada, program yang kita buat menghasilkan output _"Hello, world!"_

# Dasar-dasar

## Bagian-bagian program.
Dalam sebuah program, terdapat beberapa bagian/seksi.

Setidaknya ada 4 bagian yang umum

- **.data**
- **.rodata**
- **.bss**
- **.text**

> *Perlu dingat, isi semua bagian di atas (kecuali .text) adalah `static`

### [section .data]

Lokasi data-data yang sudah di-inisialisasi berada di sini. 

`section .data` ini bersifat **rw**- (*read write*).

### [section .rodata]

Tempat data konstan atau tidak bisa diubah.

Dalam bahasa C/C++, tempat global `const` atau `const static` berada.

Seperti namanya, `.rodata` ini **r**-- (*read only*).

### [section .bss]

Memori yang dialokasi untuk dipakai nanti disimpan di sini.

> Note: unitialized static data secara default akan bernilai 0

`.bss` bersifat **rw**- (*read write*).

### [section .text]

Tempat kode-kode yang akan dijalankan program.

Sifatnya **r**-**x** (*read exec*).

----

> Apakah moderasi tiap bagian bisa diubah ?

Ya bisa, tapi untuk sekarang kita tidak akan membahas itu.

## System Call

> _Apa itu system call ?_

System call adalah cara program berinteraksi dengan sistem operasi melalui kernel.

Saat kita melakukan syscall, kita menyuruh kernel untuk melakukan fungsi.

_Gak Paham ?_

Bahasa awamnya, **system call adalah fungsi-fungsi yang tersedia di kernel.**

# Penjelasan 

`%define` di sini adalah macro.

jadi 

```asm
%define STDOUT_FILENO 1
```

sama seperti

```c
#define STDOUT_FILENO 1
```
dalam bahasa C/C++, dan macro ini bebas kita letakkan di mana saja.

##  [section .rodata]

`db` merupakan singkatan dari "_**d**efine **b**yte(s)_"

Seperti yang kita tahu, ukuran `char` di Linux x64 adalah 1 byte / 8 bit.

**10** adalah Nilai ASCII untuk `'\n'` atau escape character _newline_

dan **0** adalah Nilai ASCII untuk `'\0'` atau NULL character.

Jadi 

```asm
msg db "Hello, world!", 10, 0
```

sama seperti

```c
const static char msg[] = "Hello, world!\n"
```

> Note : Dikarenakan `msg` berada dalam `.rodata`, maka **msg** bersifat `static` dan `const` .

## [.section .text]

Sebelum kita lanjut ke pembahasan selanjutnya, saya ingin membuat analogi system call kernel dengan menu restoran.

`nomenu` digunakan untuk menentukan menu makanan.

`ket1` digunakan untuk keterangan pertama / argumen pertama.

Berikut adalah contoh tabel menu makanan

| Nama makanan | nomenu | ket1 |
| ------------ | ------- | ---- |
| Lemper Jepang     |    1    | jumlah | 
| Tahu Bulat | 2 | jumlah |

<br/>

Instruksi `isi` digunakan untuk mengisi.

Instruksi `pesan` digunakan untuk memanggil pelayan atau menandakan kita siap memesan

<br/>

Kita diberikan kertas pesanan sebagai berikut

| No menu | ket1 |
| ------- | ----- |
|  ...  |   ...  |

Jika kita ingin memesan Lemper jepang maka kita mengisi tabelnya sebagai berikut

| No menu | ket1 |
| ------- | ---- |
|    1     |  1 |

Jika dituliskan dalam bentuk pseudocode assembly kurang lebih seperti di bawah ini.

```
isi nomenu, 1
; Mengisi nomenu dengan angka 1
isi ket1, 5
; Mengisi ket1 dengan angka 5
pesan
; Memesan lemper jepang sebanyak 5 buah
```
Maka pelayan akan menerima pesanan "Lemper Jepang", berdasarkan `nomenu` dan menyajikan 5 buah lemper berdasarkan `ket1`.

Dalam fungsi C/C++, kode di atas sama seperti

`lemper_jepang(5);`

----------------------------------------------------------------------------

Oke, kita kembali ke materi.

`global _start` digunakan agar linker bisa mengakses label `_start` dari luar.

label `_start` sama seperti fungsi `main` dalam bahasa C/C++.

Perhatikan penggunaan register di Linux x64 ini.

- **rax** digunakan untuk menentukan nomor syscall
- **rdi** digunakan untuk memberikan argumen pertama
- **rsi** digunakan untuk memberikan argumen kedua
- **rdx** digunakan untuk memberikan argumen ketiga
- **r10** digunakan untuk memberikan argumen keempat
- **r8** digunakan untuk memberikan argumen kelima
- **r9** digunakan untuk memberikan argumen keenam

Jika tulisan di atas kurang jelas bentuk fungsi C/C++nya adalah sebagai berikut.

```c
syscall_nr(arg1, arg2, arg3, arg4, arg5, arg6)
rax(rdi, rsi, rdx, r10, r8, r9)
```

### Instruksi dasar
NASM menggunakan syntax intel.

Bentuk syntaxnya kurang lebih sebagai berikut

```
instruksi dest, src
```
<br/>

`mov` (_move_) adalah instruksi untuk memindahkan data ke dalam memori atau register.

`mov x, y` sama seperti `x = y`.

<br/>

`xor` adalah operasi bitwise _xor_ .

`xor x, y` sama seperti `x ^= y`.

<br/>

`syscall` adalah instruksi untuk memanggil system call dari kernel

-----

Kita akan melakukan syscall `write` untuk mengeluarkan output _"Hello, world!"_ ke command line.

Prototipe `sys_write` adalah sebagai berikut

```c
write(int fd, const void *buf, size_t count);
```
|  syscall  | rax | rdi | rsi |  rdx  | r10 | r8 | r9 |
| --------- | --- | --- | --- | ---- | ---- | --- | -- |
| write |  1  | fd  | buf | count |  -  |  - |  - |

--------

```c
mov eax, 1
``` 
Memasukkan nilai 1 ke dalam **eax**.

Sekarang, register **rax** sudah terisi dengan nilai 1.

---------

###
```asm
mov edi, STDOUT_FILENO
```
Memasukkan nomor fd _stdout_ ke dalam **edi**.

Argumen pertama untuk `sys_write` adalah nomor file descriptor untuk ditulis

Karena kita ingin menampilkan pesan ke `stdout` maka kita mengisi **rdi** dengan nilai 1

<br/>

Saat suatu program dijalankan, setidaknya ada 3 stream yang secara default sudah terbuka.
 
`stdin` untuk menerima input, 

`stdout` menampilkan output,

dan `stderr` untuk menampilkan pesan diagnosa atau error.
 
Ketiga stream tadi memilki nomor file descriptor yang tetap.

Berikut adalah tabel 3 standard streams dan nomornya.


   | fd | value |
   | ---| ------ |
   | stdin | 0 |
   | stdout | 1 |
   | stderr | 2|
   
 `<unistd.h>` memilki tiga macro yang mendefinisikan nomor ketiga standard stream.
 
 ```c
 #define STDIN_FILENO 0
 #define STDOUT_FILENO 1
 #define STDERR_FILENO 2
 ```
 - Referensi : https://en.wikipedia.org/wiki/File_descriptor

-------

```asm
mov esi, msg
``` 
Mengisi **esi** dengan alamat _msg_.

Argumen kedua syscall `write` adalah alamat data yang ingin ditulis.

Jadi sekarang register **rsi** berisi alamat msg.

> Catatan : `msg` adalah alamat, gunakan `[]` layaknya pointer `*` dalam C/C++ untuk mengakses nilainya.

> `[msg + i]` sama seperti `*(msg + i)`.

------

```asm
mov edx, 14
```

Mengisi **edx** dengan nilai 14.

Argumen ketiga `sys_write` adalah jumlah bytes yang ingin ditulis

Ukuran `msg` tanpa karakter NULL adalah 14 bytes.

------

Kode-kode di atas tadi jika diubah ke dalam bahasa C sama seperti

```c
write(STDOUT_FILENO, msg, 14)
```

`sys_write` sudah selesai sekarang kita bisa memanggil kernel dengan instruksi `syscall`

-------------

> Pertanyaan, kenapa mengisi ke **eax**; **edi**, **esi**, **edx** ?
> Bukankah register yang dipakai **rax**, **rdi**, **rsi**, **rdx** ?

**eax** dan kawan-kawannya berukuran 32 bit, sedangkan **rax** dan kawan-kawannya berukuran 64 bit. 

Mengubah nilai register 32 bit juga akan mengubah nilai register 64 bit.

Kita akan bahas alasannya di bab selanjutnya.

------------

Selanjutnya kita akan melakukan syscall exit untuk menghentikan program

Prototipenya

```c
_exit(int status)
```

| syscall  | rax |   rdi  | rsi | rdx | r10 | r8 | r9 |
| ---------|-----|--------|-----|-----|-----|----|----|
| sys_exit |  60 | status |  -  |  -  |  -  |  - |  - |

--------

```asm
mov eax, 60
```

Mengisi nilai 60 ke dalam **eax**.

Nomor syscall untuk `sys_exit` adalah 60.

-------

```asm
xor edi, edi
```

Membuat register **edi**  bernilai 0 dengan instruksi bitwise `xor`.

`xor` digunakan untuk mengisi nilai 0 karena lebih ringan dibanding instruksi `mov`.

----

Hasilnya

```c
_exit(0)
```

syscall `_exit` sudah selesai jadi kita memanggil kernel dengan instruksi `syscall` untuk melakukan `sys_exit` sekarang.



