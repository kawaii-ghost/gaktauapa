# Instruksi Aritmatika serta basic debugging

Di bab ini kita akan belajar membuat Instuksi Aritmatika, dan juga men-debug-nya menggunakan GDB.

## Aritmatika Assmebly
Jadi aritmatika dalam assembly adalah sebuah instruksi yang di eksekusi melalui [**Arithmetic Logical Unit (ALU)**](https://en.wikipedia.org/wiki/Arithmetic_logic_unit) pada CPU. Seperti matematika pada umumnya, aritmatika di assembly memiliki fungsi yang sama, yaitu pertambahan, pengurangan, perkalian, dan seterusnya.

### Tipe Aritmatika
Berikut merupakan jenis-jenis aritmatika yang bisa kita gunakan di assembly.
| Tipe Aritmatika | Assembly | Notation |
| --------------- | -------- |----------|
| `Addition`      | **add**  | **+**    |
| `Subtraction`   | **sub**  | **-**    |
| `Multiplication`| **mul/imul**  | **x**    |
| `Division`      | **div**  | **/**    |
| `Increment`     | **inc**  | **+1**   |
| `Decrement`     | **dec**  | **-1**   |

### Addition/Substraction
Addition di assembly mengambil 2 input dan menggabungkannya menjadi satu. Sedangkan substraction mengurangi input pertama dengan input kedua. Bedanya disini kita memiliki source dan destination, dimana source ini akan ditambahkan pada destination address yang dituju.
```
add <dest>, <src>
sub <dest>, <src>
```
contoh:
```asm
xor eax, eax
; eax = 0; Membuat nilai eax menjadi 0
add eax, 100
; eax += 100; Menambah nilai eax sebanyak 100
sub eax, 10
; eax -= 10; Mengurangi nilai eax sebanyak 10
```
Instruksi diatas akan mengubah eax menjadi 90.

### Multiplication
Multiplication atau perkalian dalam assembly, Nantinya sumber akan dikalikan dengan nilai di rax.

Instruksi mul akan mengalikan src dengan rax, menghasilkan 128 bit. 64 bit bawah di rax dan 64 bit atas di rdx.

```
mul <src>
```
contoh:
```
mov eax, 2  ;set rax 2
mov ebx, 4  ;set rbx 4
mul ebx     ;kali rbx dengan rax
```
Maka nilai rax akan menjadi 8, dan nilai rdx menjadi 0.

### Division
### Increment/Decrement
Increment dalam assembly berfungsi untuk menambah nilai dari destinasi sebanyak 1. Sedangkan decrement mengurangi nilai dari destinasi sebanyak 1.
```
inc <dest>
```
contoh:
```asm
xor eax, eax  ;set rax menjadi 0
inc eax     ;eax +1
inc eax     ;eax +1
```
Maka hasilnya adalah 2.
```asm
mov eax, 10 ;set rax menjadi 10
dec eax     ;eax -1
dec eax     ;eax -1
```
maka hasilnya adalah 8.

> Perhatian, instruksi inc dan dec tidak disarankan untuk digunakan karena bisa menyebabkan partial register stall.

## Debugging di GDB
### Basic Command
| Perintah        | Fungsi   | Penggunaan |
| --------------- | -------- | ---------- |
| `help`          | **Menampilkan opsi pada suatu perintah**| **help \<argument(optional)>** |
| `run`           | **Menjalankan program** | **run <argument(optional)>** |
| `disass`        | **Mendisassamble** | **disass \<symbol atau pointer>**|
| `set`           | **Setting variable konfigurasi pada gdb**| **set \<argument>  \<value>** |
| `break`         | **Set breakpoint**| **break \<symbol atau \*address>** |
| `next`          | **Lanjut ke instruksi selanjutnya**| **next** |
| `continue`      | **Melanjutkan program setelah breakpoint** | **continue**|
| `info`          | **Menampilkan informasi**| **info \<argument>** |

### Example
1. Men-disassamble dan menganalisis instruksi yang sedang dieksekusi
Kita akan menggunakan instruksi dibawah, sebagai uji coba.
```asm
global _start
section .text
_start:
    xor eax, eax
    add eax, 10 ; add 10 to rax
    add eax, 20 ; add 20 to rax
    add eax, 30 ; add 30 to rax

exit:
    mov eax, 60 ; exit syscall
    xor edi, edi
    syscall
```
Setelah kita meng-compile instruksi diatas, kita akan menganalisa bagaimana fungsi add bekerja menggunakan GDB.

- Pertama kita akan menjalankan gdb, dengan menggunakan perintah `gdb <nama_program>`
- Setelah masuk kedalam Command Line Interface di GDB, kita akan mengetikkan perintah `set disassembly-flavor intel` untuk mengubah format disassembly-nya menjadi format intel, agar lebih mudah dibaca.
- Lalu kita akan set `step-mode` variable menjadi on, agar kita dapat mendebug instruksi assembly satu persatu, `set step-mode on`.

Ok, setelah men-setup GDB-nya, kita langsung saja ke bagian utama, yaitu menganalisa instruksi `add` pada program.
- Pertama kita akan set breakpoint pada symbol `_start`, `break _start`
- Next, kita jalankan programnya, `run`.
- Ketik `next` untuk masuk ke instruksi berikutnya.
- Kita akan meliahat registernya, dan ingat disini value rax masih 0, `info registers`.
output:
```
rax            0x0                 0
```
- Kita `next` lagi.
- Lalu lihat registernya, `info register`. Maka valuenya akan berubah, seperti dibawah
```
rax            0xa                 10
```
Kenapa bisa berubah? yup, karena kita baru saja melewati instruksi `add rax, 10`

- Ketik `disasss _start`

output:
```
Dump of assembler code for function _start:
   0x0000000000401000 <+0>:     mov    eax,0x0
   0x0000000000401005 <+5>:     add    rax,0xa
=> 0x0000000000401009 <+9>:     add    rax,0x14
   0x000000000040100d <+13>:    add    rax,0x1e
End of assembler dump.
```
Bisa dilihat diatas, saat kita men-disassemble symbol `_start`, anak panah menuju ke instruki ke-3, yang artinya instruksi ke-2 telah selesai di eksekusi, dan alhasil menambahkan 0xa atau 10 ke rax.
