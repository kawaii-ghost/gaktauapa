# Instruksi Aritmatika serta basic debugging

Di bab ini kita akan belajar membuat Instuksi Aritmatika, dan juga men-debug-nya menggunakan GDB.

## Aritmatika Assmebly
Jadi aritmatika dalam assembly adalah sebuah instruksi yang di eksekusi melalui [**Arithmetic Logical Unit (ALU)**](https://en.wikipedia.org/wiki/Arithmetic_logic_unit) pada CPU. Seperti matematika pada umumnya, aritmatika di assembly memiliki fungsi yang sama, yaitu pertambahan, pengurangan, perkalian, dan seterusnya.

### Tipe Aritmatika
Berikut merupakan jenis-jenis aritmatika yang bisa kita gunakan di assembly.
| Tipe Aritmatika | Assembly | Notation |
| --------------- | -------- |----------|
| `Addition`      | **add**  | **+**    |
| `Subtraction`   | **sub**  | **-**    |
| `Multiplication`| **mul/imul**  | **x**    |
| `Division`      | **div/idiv**  | **/**    |
| `Increment`     | **inc**  | **+1**   |
| `Decrement`     | **dec**  | **-1**   |

Default ukuran semua operasi di atas adalah 32 bit.

> Dikarenakan x86 ini prosesor yang bertipe CISC, Saya hanya membahas bagian tertentu saja.
> Ribet sekali kawan-kawan.

### Addition/Substraction
Addition di assembly mengambil 2 input dan menggabungkannya menjadi satu. Sedangkan substraction mengurangi input pertama dengan input kedua. Bedanya disini kita memiliki source dan destination, dimana source ini akan ditambahkan pada destination address yang dituju.
```
add <dest>, <src>
sub <dest>, <src>
```
contoh:
```asm
xor eax, eax
; eax = 0; Membuat nilai eax menjadi 0
add eax, 100
; eax += 100; Menambah nilai eax sebanyak 100
sub eax, 10
; eax -= 10; Mengurangi nilai eax sebanyak 10
```
Instruksi diatas akan mengubah __eax__ menjadi 90.

### Multiplication

Ada dua macam instruksi, `mul` untuk unsigned dan `imul` untuk signed.

Untuk operasi 32 bit, instruksi `mul` dan `imul` akan mengalikan sumber operan dengan __eax__.

Menghasilkan nilai 64 bit di mana __eax__ 32 bit bawah dan __edx__ 32 bit atas.

```
mul <src>
```
contoh:

```asm
mov eax, 2  ;eax =  2
mov ebx, 4  ;ebx = 4
mul ebx     ;eax:edx = eax * ebx
```
Maka nilai __eax__ akan menjadi 8, dan nilai __edx__ menjadi 0.

### Division

Seperti perkalian, `idiv` untuk signed dan `div` untuk unsigned.

Membagi sumber operan dengan nilai yang ada pada __eax__ untuk operasi 32 bit, menyimpan sisanya di __edx__

Sebelum melakukan

```
div <src>
```
contoh:
```
mov eax, 4  ;set rax 2
mov ebx, 2  ;set rbx 4
div ebx     ;bagi rbx dengan rax
```
Maka nilai __eax__ akan menjadi 2, dan nilai __edx__ menjadi 0.

### Increment/Decrement
Increment dalam assembly berfungsi untuk menambah nilai dari destinasi sebanyak 1. Sedangkan decrement mengurangi nilai dari destinasi sebanyak 1.
```
inc <dest>
```
contoh:
```asm
xor eax, eax  ;set rax menjadi 0
inc eax     ;eax +1
inc eax     ;eax +1
```
Maka hasilnya adalah 2.
```asm
mov eax, 10 ;set rax menjadi 10
dec eax     ;eax -1
dec eax     ;eax -1
```
maka hasilnya adalah 8.

> Perhatian, instruksi inc dan dec tidak disarankan untuk digunakan karena bisa menyebabkan partial register stall.

## Debugging di GDB
### Basic Command
| Perintah        | Fungsi   | Penggunaan |
| --------------- | -------- | ---------- |
| `help`          | **Menampilkan opsi pada suatu perintah**| **help \<argument(optional)>** |
| `run`           | **Menjalankan program** | **run <argument(optional)>** |
| `disass`        | **Mendisassamble** | **disass \<symbol atau pointer>**|
| `set`           | **Setting variable konfigurasi pada gdb**| **set \<argument>  \<value>** |
| `break`         | **Set breakpoint**| **break \<symbol atau \*address>** |
| `next`          | **Lanjut ke instruksi selanjutnya**| **next** |
| `continue`      | **Melanjutkan program setelah breakpoint** | **continue**|
| `info`          | **Menampilkan informasi**| **info \<argument>** |
| `commands`       | **Membuat auto script saat menginjak breakpoint** | **commands <range of breakpoint, example: 1-4, 2>** |

Example:
### Men-disassamble dan menganalisis instruksi yang sedang dieksekusi
Kita akan menggunakan instruksi dibawah, sebagai uji coba.
```asm
global _start
section .text
_start:
    xor eax, eax
    add eax, 10 ; add 10 to rax
    add eax, 20 ; add 20 to rax
    add eax, 30 ; add 30 to rax

exit:
    mov eax, 60 ; exit syscall
    xor edi, edi
    syscall
```
Setelah kita meng-compile instruksi diatas, kita akan menganalisa bagaimana fungsi add bekerja menggunakan GDB.

- Pertama kita akan menjalankan gdb, dengan menggunakan perintah `gdb <nama_program>`
- Setelah masuk kedalam Command Line Interface di GDB, kita akan mengetikkan perintah `set disassembly-flavor intel` untuk mengubah format disassembly-nya menjadi format intel, agar lebih mudah dibaca.
- Lalu kita akan set `step-mode` variable menjadi on, agar kita dapat mendebug instruksi assembly satu persatu, `set step-mode on`.

Ok, setelah men-setup GDB-nya, kita langsung saja ke bagian utama, yaitu menganalisa instruksi `add` pada program.
- Pertama kita akan set breakpoint pada symbol `_start`, `break _start`
- Next, kita jalankan programnya, `run`.
- Ketik `next` untuk masuk ke instruksi berikutnya.
- Kita akan meliahat registernya, dan ingat disini value rax masih 0, `info registers`.
output:


![](https://user-images.githubusercontent.com/92920739/186277915-e939fba4-92ca-49f0-b1ca-372ede0746c3.png)


- Kita `next` lagi.
- Lalu lihat registernya, `info register`. Maka valuenya akan berubah, seperti dibawah


![](https://user-images.githubusercontent.com/92920739/186277755-63b0db85-0f79-4581-8c8d-4c9ca8f73558.png)


Kenapa bisa berubah? yup, karena kita baru saja melewati instruksi `add eax, 10`

- Ketik `disasss _start`

output:


![](https://user-images.githubusercontent.com/92920739/186277505-fd15700d-f256-48df-a44e-cf1fb245df32.png)


Bisa dilihat diatas, saat kita men-disassemble symbol `_start`, anak panah menuju ke instruki ke-3, yang artinya instruksi ke-2 telah selesai di eksekusi, dan alhasil menambahkan 0xa atau 10 ke rax.

### Membuat script automasi yang berjalan saat menginjak breakpoint.
```asm
global _start
section .text
_start:
    mov eax, 2
    mov ebx, 4
    div ebx   
    mov ebx, 4
    div ebx   

exit:
    mov eax, 60 
    xor edi, edi
    syscall
```
- Pertama kita set dulu breakpointnya, contoh:

![image](https://user-images.githubusercontent.com/92920739/186534301-1eb74380-1e57-4f68-8fbc-36bf8a0b6b24.png)

- Lalu kita ketikkan perintah `commands` dan tentukan breakpoint mana saja yang mau kita buat skrip automasi.
> Note: Untuk melihat list breakpoint kalian bisa menggunakan perintah `info breakpoints`
> ![image](https://user-images.githubusercontent.com/92920739/186535010-7d4fff01-aa44-41c5-965d-eac06d2273c5.png)

![image](https://user-images.githubusercontent.com/92920739/186535285-20c39ffa-f380-44a9-bc98-5ac67bf9b91a.png)

- Setelah itu kalian bisa mengetikkan skrip yang nantinya akan dieksekusi saat breakpoint.
contoh:

![image](https://user-images.githubusercontent.com/92920739/186537141-17fd49c6-c5d0-4fb1-9a1a-3d23df21bdb5.png)

- Saat kita `run`, dan menginjak breakpoint maka ama muncul output dari script yang kita buat tadi.

![image](https://user-images.githubusercontent.com/92920739/186537405-7201b2a1-ad5d-42da-a756-90d3f7d8f1f6.png)
